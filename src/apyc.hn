/* -*- mode: fundamental; c-file-style: "stroustrup"; indent-tabs-mode: nil -*- */

/* apyc: Bison Parser */

/* Authors: */

%define semantic_tree_type "AST"

%{
  #include <string>
  #include <stack>
  #include "apyc.h"
  #include "ast.h"
  #include <stack>

  using namespace std;

  static AST_Ptr theTree;

  /* Utilities */
  /** Return a new unop node corresponding to OPERANDS, which is the list of
   *  right-hand-side semantic values of a unop production (consisting of a
   *  token for the operator, followed by the AST for the operand). */
  static AST_Ptr make_unop (const List_Ptr& operands);

  /** Return a new binop node corresponding to OPERANDS, which is the list of
   *  right-hand-side semantic values of a binop production (consisting of an
   *  AST for the first operand, a token for the operator, and an AST for the
   *  second operand). */
  static AST_Ptr make_binop (const List_Ptr& operands, const int token);

  /** Return a new ID node, where the text of the identifier is given by
   *  TOKEN. */
  static AST_Ptr make_id (AST_Ptr& token);

  static stack<int> indents;

%}

%debug
%define error_function error

/* A token declaration such as
 *   %token INDENT
 * declares a new integer constant INDENT, which serves as a syntactic category
 * (suitable for output by the lexer) identifying a kind of token, which we
 * also often refer to as INDENT. A declaration such as
 *   %token IF "if"
 * defines a constant IF and makes it the syntactic category for the token
 * "if".  The built-in function yyexternal_token_name(...) maps between
 * syntactic categories (like IF) and the token strings defined in these
 * %token declarations (like "if").
 *
 * The Horn system uses tokens as leaf nodes and as AST node operators.  A
 * rule such as
 *     if_stmt: "if"^ expression ":"! ...
 * with no action, by default creates an AST node whose operator is an "if"
 * token (with syntactic category IF, given the %token declaration above).
 * When the node type does not correspond to a token that appears in the
 * program, we define a dummy token type that serves only as an AST
 * node type.  For example, we can define
 *     %token DICT_DISPLAY ...
 * and then use
 *     dict_display: "{"! key_datum_list? "}"!
 *              { $$ = $^(DICT_DISPLAY, $*); }
 * in the grammar (using DICT_DISPLAY only in actions, not as a grammar
 * symbol).
 *
 * In this skeleton, we've used a simple kludge to extract the printed forms
 * of AST operators from the operators themselves.  When a token such as IF
 * is the operator, yyexternal_token_name returns the operator name directly.
 * When there is no such correspondence, as with DICT_DISPLAY, we'll define
 *     %token DICT_DISPLAY "@dict_display"
 * Since "@dict_display" is not a valid token (it would be an error for this
 * to appear in any Python program) and does not appear in the grammar, this
 * declaration has no effect on the language recognized.  However, it
 * still provides an easy way to find the external name of an operator (just
 * strip off the leading "@").  (We can't just use "dict_display", since that
 * would tell Horn to define 'dict_display' as a token, whereas it would be a
 * simple identifier if it actually appeared in a Python program.  This is
 * where the kludginess comes in.) The AST_Tree::external_name method does
 * this conversion, converting tokens that are supposed to represent
 * node operators to printable strings.
 */

%token ASGN
%token ASSIGN "@assign"
%token ATTREF "@attributeref"
%token BINOP "@binop"
%token BLOCK "@block"
%token BREAK "@break"
%token CALL "@call"
%token CLASS "@class"
%token COMPARE "@compare"
%token DEDENT
%token DEF "@def"
%token DICT_DISP "@dict_display"
%token EMPTY
%token EQUAL
%token EXPR_LIST "@expr_list"
%token FOR "@for"
%token FORMALS "@formals_list"
%token IF "@if_expr"
%token INDENT
%token LEFT_COMPARE "@left_compare"
%token LIST_DISP "@list_display"
%token MODULE "@module"
%token NATIVE "@native"
%token PAIR "@pair"
%token PRINT "@print"
%token PRINTLN "@println"
%token SIMPLE_STMT "@simple"
%token SLICE "@slicing"
%token STMT_LIST "@stmt_list"
%token SUBSCRIPT "@subscription"
%token TARLIST "@target_list"
%token TUPLE "@tuple"
%token TYPED "@typed_id"
%token TYPE_FOR "@type_formals_list"
%token UNOP "@unop"

%%

program : (input_input | eval_input | interactive_input | file_input)* { theTree = $^(MODULE, $*); $$ = NULL; }
        ;

/* Grammar */

input_input : expression_list '\n'!
            ;

eval_input : expression_list ('\n'!)*
           ;

interactive_input : (stmt_list)? '\n'!?
                  | compound_stmt '\n'!?
                  ;

file_input : ('\n'! | statement)*
           ;

classname : identifier
          ;

classdef : "class" classname ":"! suite { AST_Ptr formal = $^(TYPE_FOR); formal->set_loc(yysource_location()); $$ = $^(CLASS, $classname, formal, $suite); }
         ;

stringpart : STRING
              | RAWSTRING
              ;

stringliteral : stringliteral stringpart { $stringliteral.value()->as_token()->append_text($stringpart.value()->as_token()->string_text()); $$ = $stringliteral; }
              ;

funcname : identifier
         ;

parameter : identifier
          ;

defparameter : parameter
             ;

defparameter : parameter ASGN! expression { $$ = $^(TYPED, $*); }
             ;

parameter_list : (defparameter ","!)* (defparameter (","!)?) { $$ = $^(FORMALS, $*); }
               | /* empty */ { AST_Ptr tok = $^(FORMALS); tok->set_loc(yysource_location()); $$ = tok; }
               ;

funcdef : "def"! funcname "("! (parameter_list) ")"! ":"! suite
            { $$ = $^(DEF, $funcname, $parameter_list, $^(EMPTY), $suite); }
        | "def"! funcname "("! (parameter_list) ")"! ":"!
            ("native"! stringliteral '\n'!
            | '\n'! INDENT! "native"! stringliteral '\n'! DEDENT!)
           { $$ = $^(DEF, $funcname, $parameter_list, $^(BLOCK, $^(NATIVE, $stringliteral))); }
        ;

for_stmt : "for"! target_list "in"! expression_list
            ":"! suite ("else"! ":"! suite)? { $$ = $^(FOR, $*); }
            ;

while_stmt : "while"^ expression ":"! suite ("else"! ":"! suite)?
            ;

if_stmt : "if"! expression ":"! suite
            ( "elif"! expression ":"! suite)*
            ("else"! ":" suite)? { $$ = $^(IF, $*); }
            ;

stmt_list : simple_stmt (";"! simple_stmt)+ (";"!)?
          | simple_stmt (";"!)?
          ;

statement : stmt_list '\n'! | compound_stmt
          ;

suite : stmt_list '\n'! { $$ = $^(BLOCK, $*); }
      | '\n'! INDENT! statement+ DEDENT! { $$ = $^(BLOCK, $*); }
      ;

compound_stmt : if_stmt
              | while_stmt
              | for_stmt
              | funcdef
              | classdef
              ;

name : identifier
     ;

continue_stmt : continue { $$ = AST::make_token(SIMPLE_STMT, $continue.text_size(), $continue.c_text()); }
              ;

continue : "continue"
         ;

break_stmt : break { $$ = AST::make_token(SIMPLE_STMT, $break.text_size(), $break.c_text()); }
           ;

break : "break"
      ;

return_stmt : "return"^ (expression_list)?
            ;

print_stmt : "print"! print_list { $$ = $^(PRINT, $^(EMPTY), $print_list); }
            | "print"! (println_list)? { $$ = $^(PRINTLN, $^(EMPTY), $println_list); }
           ;

pass_stmt : pass { $$ = AST::make_token(SIMPLE_STMT, $pass.text_size(), $pass.c_text()); }
          ;

pass : "pass"
     ;

target : identifier
       | attributeref
       | subscription
       | slicing
       ;

target_list : ("("!)? target (","! target)* (","!)? (")"!)? { $$ = $^(TARLIST, $*); }
            | ("["!)? target (","! target)* (","!)? ("]"!)? { $$ = $^(TARLIST, $*); }
            ;

assignment_stmt : expression_list ASGN! as_stmt1 { $$ = $^(ASSIGN, $*); }
                ;
                
as_stmt1 : expression_list ASGN! as_stmt1 { $$ = $^(ASSIGN, $*); }
         | expression_list
         ;

expression_stmt : expression_list { $$ = $^(STMT_LIST, $*); }
                ;

simple_stmt : expression_stmt
            | assignment_stmt
            | print_stmt
            | return_stmt
            | break_stmt
            | continue_stmt
            ;

expression_list : expression (','! expression)* (','!) { $$ = $^(TUPLE, $*); }
                | expression (','! expression)+ { $$ = $^(TUPLE, $*); }
                | expression
                ;

print_list : expression (','! expression)* (','!) { $$ = $^(EXPR_LIST, $*); }
           ;

println_list : expression (','! expression)* { $$ = $^(EXPR_LIST, $*); }
            ;

not_test : comparison | "not"! not_test
         ;

and_test : not_test | and_test "and"^ not_test
         ;

or_test : and_test | or_test "or"^ and_test
        ;

conditional_expression : P2=or_test "if"! P1=or_test "else"! P3=expression { $$ = $^(IF, $P1, $P2, $P3); }
                       | or_test
                       ;

old_expression : or_test
               ;

expression : conditional_expression
           ;

comp_operator : '<' | '>' | EQUAL | ">=" | "<=" | "!="
              | "is" ("not")? | ("not")? "in"
              ;

comparison : (left_comparison|a_expr) comp_operator a_expr %expand { $$ = make_binop($*, COMPARE); }
           | a_expr
           ;

left_comparison : (left_comparison|a_expr) comp_operator a_expr %expand { $$ = make_binop($*, LEFT_COMPARE); }
                ;

a_expr : m_expr
       | a_expr ('-'|'+') m_expr %expand { $$ = make_binop($*, BINOP); }
       ;

m_expr : u_expr
       | m_expr ('*'|"//"|"/"|'%') u_expr %expand { $$ = make_binop($*, BINOP); }
       ;

u_expr : power
       | ('-'|'+') u_expr %expand { $$ = make_unop($*); }
       ;

power : primary ("**" u_expr)? { if ( ! $u_expr.missing() ) { $$ = make_binop( $*, BINOP); } }
      ;

keyword_item : identifier ASGN! expression
             ;

keyword_arguments : keyword_item (','! keyword_item)*
                  ;

positional_arguments : expression (','! expression)*
                     ;

argument_list : positional_arguments (','! keyword_arguments)?
              | keyword_arguments
              ;

call : primary '('! (argument_list (','!)?)? ')'! { $$ = $^(CALL, $primary, $^(EXPR_LIST, $argument_list)); }
     ;

ellipsis : "..."!
         ;

upper_bound : expression
            ;

lower_bound : expression
            ;

short_slice : (lower_bound) ':'! (upper_bound)
            | ':'! upper_bound { $$ = $^(EMPTY), $upper_bound; }
            | lower_bound ':'! { $$ = $lower_bound, $^(EMPTY); }
            | ':'!             { $$ = $^(EMPTY), $^(EMPTY); }
            ;

simple_slicing : primary '['! (lower_bound) ':'! (upper_bound) ']'! { $$ = $^(SLICE, $*); }
               | primary '['! ':'! (upper_bound) ']'! { $$ = $^(SLICE, $primary, $^(EMPTY), $upper_bound); }
               | primary '['! (lower_bound) ':'! ']'! { $$ = $^(SLICE, $primary, $lower_bound, $^(EMPTY)); }
               | primary '['! ':'! ']'!               { $$ = $^(SLICE, $primary,  $^(EMPTY), $^(EMPTY)); }
               ;

slicing : simple_slicing
        ;

subscription : primary '['! expression_list ']'! { $$ = $^(SUBSCRIPT, $*); }
             ;

attributeref : primary '.'! identifier { $$ = $^(ATTREF, $*); }
             ;

primary : atom | attributeref | subscription
        | slicing | call
        ;

key_datum : expression ':'! expression { $$ = $^(PAIR, $*); }
          ;

key_datum_list : key_datum (','! key_datum)* (','!)?
               ;

dict_display : '{'! (key_datum_list)? '}'! { $$ = $^(DICT_DISP, $^(EMPTY)); }
             | '{'! (key_datum_list) '}'! { $$ = $^(DICT_DISP, $key_datum_list); }
             ;

old_expression_list : old_expression ((','! old_expression)+ (','!)?)? ;

list_display : '['! expression (','! expression)* (','!)? ']'! { $$ = $^(LIST_DISP, $*); }
             ;

parenth_form : '('! (expression_list)? ')'!
             ;

stringliteral : STRING | RAWSTRING
              ;

literal : stringliteral | integer
        ;

enclosure : parenth_form | list_display
          | dict_display
          ;

atom : identifier | literal | enclosure
     ;

integer : INT_LITERAL
        ;

identifier : ID
           ;

keyword : "and"     | "del"     | "from"    | "not"     | "while"
        | "as"      | "elif"    | "global"  | "or"      | "with"
        | "assert"  | "else"    | "if"      | "pass"    | "yield"
        | "break"   | "except"  | "import"  | "print"
        | "class"   | "exec"    | "in"      | "raise"
        | "continue"| "finally" | "is"      | "return"
        | "def"     | "for"     | "lambda"  | "try"
        ;

/* Shoulda been built-in */
_DIGIT : ('0' .. '9')
       ;

_LOWER : ('a' .. 'z')
       ;

_UPPER : ('A' .. 'Z')
       ;

_LETTER : (_LOWER | _UPPER)
        ;

/* Identifiers */
ID : (_LETTER | '_') (_LETTER | _DIGIT | '_')*
   ;

/* Operators */
ASGN : '='
      ;

EQUAL : "=="
      ;

/* Integers */
_OCTDIGIT : ('0' .. '7')
          ;
_OCTINTEGER : '0' _OCTDIGIT+
            ;

_HEXDIGIT : _DIGIT | ('a' .. 'f') | ('A' .. 'F')
          ;
_HEXINTEGER : '0' ('x' | 'X') _HEXDIGIT+
            ;

_NONZERODIGIT : ('1' .. '9')
              ;

_DECIMALINTEGER : _NONZERODIGIT _DIGIT* | '0'
                ;

INT_LITERAL : _DECIMALINTEGER | _OCTINTEGER | _HEXINTEGER
            ;

/* Strings whoop whoop */
_STRINGCHARS : _ANY - ('\\'|'\''|'"'|'\n')
             ;
_SHORTSTRINGCHARS : _STRINGCHARS | '\\'
                  ;
_LONGSTRINGCHARS : _STRINGCHARS  | '\n'
                ;

_RAWESCAPESEQ : '\\' _ANY
              ;
_ESCAPESEQ : _RAWESCAPESEQ | '\\'  _OCTDIGIT _OCTDIGIT? _OCTDIGIT?
           ;

_STRING_NOT_DOUBLEQ : _STRINGCHARS | '\''
                    ;
_STRING_NOT_SINGLEQ : _STRINGCHARS | '"'
                    ;

_SHORTSTRING : '\'' ( _STRING_NOT_SINGLEQ | _ESCAPESEQ )* '\''
             | '"' ( _STRING_NOT_DOUBLEQ | _ESCAPESEQ )* '"'
             ;
_RAWSHORTSTRING : '\'' ( _STRING_NOT_SINGLEQ | _RAWESCAPESEQ )* '\''
                | '"' ( _STRING_NOT_DOUBLEQ | _RAWESCAPESEQ )* '"'
                ;
_LONGSTRING_SINGLE : '"'  | _LONGSTRINGCHARS | _LONGSTRINGCHARS '\'' | _LONGSTRINGCHARS "''" | _LONGSTRINGCHARS "\\'''"
                   ;
_LONGSTRING_DOUBLE : '\'' | _LONGSTRINGCHARS | _LONGSTRINGCHARS '"' | _LONGSTRINGCHARS "\"\"" | _LONGSTRINGCHARS "\\\"\"\""
                   ;

_LONGSTRING : "\"\"\"" ( _LONGSTRING_DOUBLE | _ESCAPESEQ )* "\"\"\""
            | "'''" ( _LONGSTRING_SINGLE | _ESCAPESEQ )* "'''"
            ;
_RAWLONGSTRING : "\"\"\"" ( _LONGSTRING_DOUBLE | _RAWESCAPESEQ )* "\"\"\""
            | "'''" ( _LONGSTRING_SINGLE | _RAWESCAPESEQ )* "'''"
            ;

STRING : _SHORTSTRING  { $$ = AST::make_token(STRING, $TEXT_SIZE - 2, $TEXT + 1); }
       | _LONGSTRING { $$ = AST::make_token(STRING, $TEXT_SIZE - 6, $TEXT + 3); }
       ;
RAWSTRING : ('r'|'R') _RAWSHORTSTRING {  $$ = AST::make_token(RAWSTRING, $TEXT_SIZE - 3, $TEXT + 2); }
          |  ('r'|'R') _RAWLONGSTRING {  $$ = AST::make_token(RAWSTRING, $TEXT_SIZE - 7, $TEXT + 4); }
          ;

/* Handle bad strings */
* : ( ('r'|'R')? ( '\'' ( _STRING_NOT_SINGLEQ | _ESCAPESEQ )*
  | '"' ( _STRING_NOT_DOUBLEQ | _ESCAPESEQ )* )) { error(yysource_location(), "unterminated short string"); }
  ;

* : ( ('r'|'R')? ( ("\"\"\"" ( _LONGSTRING_DOUBLE | _ESCAPESEQ )* )
  | ("'''" ( _LONGSTRING_SINGLE | _ESCAPESEQ )* ) )) { error(yysource_location(), "unterminated long string"); }
  ;

/* Comments and blank lines */
_SAMELINE : _ANY - ('\n');
* : (' ' | '\t' | '\r')* '#' _SAMELINE* _EOL %prefer { YYIGNORE; }
  | _BOL  (' ' | '\t' | '\r' | '\n')* _EOL %prefer { YYIGNORE; }
  ;

/* Handle indentation at the beginning of a line. */
* : _BOL (' ' | '\t')* %prefer { processIndent($TEXT); }
  ;

/* Normally, throw away whitespace other than newline. */
* : (' ' | '\t' | '\r')+
  ;

%%

bool debugParser = false;

static AST_Ptr
make_unop (const List_Ptr& operands)
{
    return YYMAKE_TREE (UNOP, make_id (operands->at (0)), operands->at (1));
}

static AST_Ptr
make_binop (const List_Ptr& operands, const int token)
{
    return YYMAKE_TREE (token, operands->at (0), make_id (operands->at (1)),
                        operands->at (2));
}

static AST_Ptr
make_id (AST_Ptr& token)
{
    AST_Ptr result = AST::make_token (ID, token->text_size (),
                                      token->as_chars (), false);
    result->set_loc (token->loc ());
    return result;
}

int
AST::lineNumber ()
{
    return yylocation_line (loc ());
}

void
parse (FILE* f, const string& name)
{
    if (debugParser)
        yydebug = 1;
    yypush_lexer (f, name);
    theTree = NULL;
    yyparse ();
    if (theTree != NULL) {
        theTree->print (cout, 0);
    }
}

int
indentLength (const char* text)
{
    int size = strlen(text);
    int blnks = 0;
    for(int i = 0; i < size; i++) {
        switch (text[i] ) {
        default: break;
        case ' ': blnks += 1; break;
        case '\t': blnks += 8 - (blnks % 8); break;
        }
    }
    return blnks;
}

void processIndent( const char* text)
{
  int length = indentLength(text);
  if ( indents.empty() ) {
    indents.push(0);
  }
  if ( length > indents.top()  ) {
    indents.push(length);
    yyqueue_token( INDENT, 0 );
  } else if ( length < indents.top() ) {
    while ( !indents.empty() ) {
      indents.pop();
      if ( length < indents.top() ) {
        yyqueue_token( DEDENT, 0 );
        continue;
      }
      if ( length != indents.top()){
        error(yysource_location(), "inconsistent indentation");
      }
      if ( length == indents.top() ) {
        yyqueue_token( DEDENT, 0 );
        break;
      }
    }
  }
}
