/* -*- mode: fundamental; c-file-style: "stroustrup"; indent-tabs-mode: nil -*- */

/* apyc: Bison Parser */

/* Authors: */

/** idreg = [a-zA-Z_] [a-zA-Z_0-9]*
 * attreg = identifier|literal|enclosure|attributeref|subscription|slicing|call
 * '.' [a-zA-Z_][a-zA-Z_0-9]* */

%define semantic_tree_type "AST"

%{
  #include <string>
  #include <stack>
  #include "apyc.h"
  #include "ast.h"
  #include <stack>

  using namespace std;

  static AST_Ptr theTree;

  /* Utilities */
  /** Return a new unop node corresponding to OPERANDS, which is the list of
   *  right-hand-side semantic values of a unop production (consisting of a
   *  token for the operator, followed by the AST for the operand). */
  static AST_Ptr make_unop (const List_Ptr& operands);

  /** Return a new binop node corresponding to OPERANDS, which is the list of
   *  right-hand-side semantic values of a binop production (consisting of an
   *  AST for the first operand, a token for the operator, and an AST for the
   *  second operand). */
  static AST_Ptr make_binop (const List_Ptr& operands, const int token);

  /** Return a new ID node, where the text of the identifier is given by
   *  TOKEN. */
  static AST_Ptr make_id (AST_Ptr& token);

  void validTargetList(const AST_Ptr& token);
  string getTokenType(const AST_Ptr& token);

  static stack<int> indents;

  static int function_depth = 0;
  static int loop_depth = 0;
  static bool in_class = false;

%}

%debug
%define error_function error

/* A token declaration such as
 *   %token INDENT
 * declares a new integer constant INDENT, which serves as a syntactic category
 * (suitable for output by the lexer) identifying a kind of token, which we
 * also often refer to as INDENT. A declaration such as
 *   %token IF "if"
 * defines a constant IF and makes it the syntactic category for the token
 * "if".  The built-in function yyexternal_token_name(...) maps between
 * syntactic categories (like IF) and the token strings defined in these
 * %token declarations (like "if").
 *
 * The Horn system uses tokens as leaf nodes and as AST node operators.  A
 * rule such as
 *     if_stmt: "if"^ expression ":"! ...
 * with no action, by default creates an AST node whose operator is an "if"
 * token (with syntactic category IF, given the %token declaration above).
 * When the node type does not correspond to a token that appears in the
 * program, we define a dummy token type that serves only as an AST
 * node type.  For example, we can define
 *     %token DICT_DISPLAY ...
 * and then use
 *     dict_display: "{"! key_datum_list? "}"!
 *              { $$ = $^(DICT_DISPLAY, $*); }
 * in the grammar (using DICT_DISPLAY only in actions, not as a grammar
 * symbol).
 *
 * In this skeleton, we've used a simple kludge to extract the printed forms
 * of AST operators from the operators themselves.  When a token such as IF
 * is the operator, yyexternal_token_name returns the operator name directly.
 * When there is no such correspondence, as with DICT_DISPLAY, we'll define
 *     %token DICT_DISPLAY "@dict_display"
 * Since "@dict_display" is not a valid token (it would be an error for this
 * to appear in any Python program) and does not appear in the grammar, this
 * declaration has no effect on the language recognized.  However, it
 * still provides an easy way to find the external name of an operator (just
 * strip off the leading "@").  (We can't just use "dict_display", since that
 * would tell Horn to define 'dict_display' as a token, whereas it would be a
 * simple identifier if it actually appeared in a Python program.  This is
 * where the kludginess comes in.) The AST_Tree::external_name method does
 * this conversion, converting tokens that are supposed to represent
 * node operators to printable strings.
 */

%token ASGN
%token ASSIGN "@assign"
%token ATTREF "@attributeref"
%token BINOP "@binop"
%token BLOCK "@block"
%token BREAK "@break"
%token CALL "@call"
%token CLASS "@class"
%token COMPARE "@compare"
%token CONTINUE "@continue"
%token DEDENT
%token DEF "@def"
%token DICT_DISP "@dict_display"
%token EMPTY
%token EQUAL
%token EXPR_LIST "@expr_list"
%token FOR "@for"
%token FORMALS "@formals_list"
%token FUNCTION_TYPE "@function_type"
%token IF "@if"
%token INDENT
%token LEFT_COMPARE "@left_compare"
%token LIST_DISP "@list_display"
%token MODULE "@module"
%token NATIVE "@native"
%token PAIR "@pair"
%token PRINT "@print"
%token PRINTLN "@println"
%token RETURN "@return"
%token SIMPLE_STMT "@simple"
%token SLICE "@slicing"
%token STMT_LIST "@stmt_list"
%token SUBSCRIPT "@subscription"
%token TARLIST "@target_list"
%token TUPLE "@tuple"
%token TYPE "@type"
%token TYPED_ID "@typed_id"
%token TYPE_FOR "@type_formals_list"
%token TYPE_LIST "@type_list"
%token TYPE_OP
%token UNOP "@unop"
%token WHILE "@while"

%%

program : (input_input | eval_input | interactive_input | file_input)* { theTree = $^(MODULE, $*); $$ = NULL; }
        ;

/* Grammar */

input_input : expression_list NEWLINE!
            ;

eval_input : expression_list (NEWLINE!)*
           ;

interactive_input : (stmt_list)? NEWLINE!
                  | compound_stmt NEWLINE!?
                  ;

file_input : (NEWLINE! | statement)*
           ;

classname : identifier
          ;

classdef : "class" classname ("of"! "["! (type_var)* "]"!)? ":"! suite
         { AST_Ptr formal = $^(TYPE_FOR, $type_var);
           formal->set_loc(yysource_location());
           $$ = $^(CLASS, $classname, formal, $^(BLOCK, $suite));
         }
         ;

stringpart : STRING
           | RAWSTRING
           ;

stringliteral : stringliteral stringpart { $stringliteral.value()->as_token()->append_text($stringpart.value()->as_token()->string_text()); $$ = $stringliteral; }
              ;

funcname : identifier
         ;

parameter : identifier
          ;

defparameter : parameter | typed_id
             ;

defparameter : parameter ASGN! expression { $$ = $^(TYPED_ID, $*); }
             ;

parameter_list : (defparameter ","!)* (defparameter (","!)?) { $$ = $^(FORMALS, $*); }
               | /* empty */ { AST_Ptr tok = $^(FORMALS); tok->set_loc(yysource_location()); $$ = tok; }
               ;

funcdef : "def"! funcname "("! (parameter_list) ")"! type0 ":"! suite
            { $$ = $^(DEF, $funcname, $parameter_list, $type0, $^(BLOCK, $suite)); }
        | "def"! funcname "("! (parameter_list) ")"! type0 ":"!
            ("native"! stringliteral NEWLINE!
            | NEWLINE! INDENT! "native"! stringliteral NEWLINE! DEDENT!)
           { $$ = $^(DEF, $funcname, $parameter_list, $type0, $^(BLOCK, $^(NATIVE, $stringliteral))); }
        ;

for_stmt : "for"! target_list "in"! expression_list
            ":"! while_suite else_suite { $$ = $^(FOR, $*); }
            ;

while_stmt : "while"! expression ":"! while_suite else_suite { $$ = $^(WHILE, $*); }
            ;

if_stmt : "if"! expression ":"! while_suite
            else_suite { $$ = $^(IF, $*); }
        | "if"! expression ":"! while_suite
            elif_suite { $$ = $^(IF, $*); }
            ;

elif_suite : "elif"! expression ":"! while_suite elif_suite{ $$ = $^(IF, $*); }
           | else_suite
           ;

else_suite : "else"! ":"! while_suite { $$ = $^(STMT_LIST, $*); }
           | /* empty */ { $$ = $^(EMPTY); }
           ;

stmt_list : simple_stmt (";"! simple_stmt)+ (";"!)?
          | simple_stmt (";"!)?
          ;

statement : stmt_list NEWLINE! | compound_stmt
          ;

suite : stmt_list NEWLINE!
      | NEWLINE! INDENT! statement+ DEDENT!
      ;

while_suite : simple_stmt (";"! simple_stmt)+ (";"!)? NEWLINE! { $$ = $^(STMT_LIST, $*); }
      | simple_stmt (";"!)?
      | NEWLINE! INDENT! statement statement+ DEDENT! { $$ = $^(STMT_LIST, $*); }
      | NEWLINE! INDENT! statement DEDENT!
      ;

compound_stmt : if_stmt
              | while_stmt
              | for_stmt
              | funcdef
              | classdef
              ;

continue_stmt : "continue"! { AST_Ptr tok = $^(CONTINUE); tok->set_loc(yysource_location()); $$ = tok; }
              ;

break_stmt : "break"! { AST_Ptr tok = $^(BREAK); tok->set_loc(yysource_location()); $$ = tok; }
           ;

return_stmt : "return"! (expression_list)?
            { if ($expression_list.missing()) {
                AST_Ptr tok = $^(RETURN, $^(EMPTY)); tok->set_loc(yysource_location()); $$ = tok;
              } else {
                $$ = $^(RETURN, $*);
              }
            }
            ;

print_stmt : "print"! { $$ = $^(PRINTLN, $^(EMPTY), $^(EXPR_LIST)); }
           | "print"! println_list { $$ = $^(PRINTLN, $^(EMPTY), $println_list); }
           | "print"!  ">>"! expression { $$ = $^(PRINTLN, $expression, $^(EXPR_LIST)); }
           | "print"!  ">>"! expression ','! println_list { $$ = $^(PRINTLN, $expression, $println_list); }
           | "print"!  ">>"! expression ','! print_list { $$ = $^(PRINT, $expression, $print_list); }
           | "print"! print_list { $$ = $^(PRINT, $^(EMPTY), $print_list); }
           ;


print_list : expression (','! expression)* (','!) { $$ = $^(EXPR_LIST, $*); }
           | /* empty */ { $$ = $^(EXPR_LIST); }
           ;

println_list : expression (','! expression)* { $$ = $^(EXPR_LIST, $*); }
             | /* empty */ { $$ = $^(EXPR_LIST); }
             ;

pass_stmt : pass { AST_Ptr tok = $^(STMT_LIST); tok->set_loc(yysource_location()); $$ = tok; }
          ;

pass : "pass"
     ;

target : identifier
       | attributeref
       | subscription
       | slicing
       | typed_id
       ;

target_list : ("("!) target (","! target)* (","!)? (")"!) { $$ = $^(TARLIST, $*); }
            | ("["!) target (","! target)* (","!)? ("]"!) { $$ = $^(TARLIST, $*); }
            | ("("!)? target (")"!)?
            | "("! target (','! target)+ ")"!              { $$ = $^(TARLIST, $*); }
            ;

assignment_stmt : (expression_list | target_list | id_type_op type) ASGN! as_stmt1
                  {
                    if (!($id_type_op.missing())) $$ = $^(ASSIGN, $^(TYPED_ID, $id_type_op, $type), $as_stmt1);
                    else $$ = $^(ASSIGN, $*);
                    if (!($expression_list.missing())) validTargetList($expression_list.value());
                  }
                ;

as_stmt1 : expression_list ASGN! as_stmt1 { $$ = $^(ASSIGN, $*); }
         | expression_list
         ;

expression_stmt : expression_list { $$ = $^(STMT_LIST, $*); }
                ;

simple_stmt : expression_stmt
            | assignment_stmt
            | print_stmt
            | return_stmt
            | break_stmt
            | continue_stmt
            | pass_stmt
            ;

expression_list : expression (','! expression)+ (','!) { $$ = $^(TUPLE, $*); }
                | expression (','! expression)+ { $$ = $^(TUPLE, $*); }
                | expression ','! { $$ = $^(TUPLE, $*); }
                | expression
                ;

not_test : comparison | "not" not_test { $$ = make_unop($*); }
         ;

and_test : not_test | and_test "and"^ not_test
                    ;

or_test : and_test | or_test "or"^ and_test
        ;

conditional_expression : P2=or_test "if"! P1=or_test "else"! P3=expression { $$ = $^(IF, $P1, $P2, $P3); }
                       | or_test
                       ;

expression : conditional_expression
//           | NEWLINE INDENT conditional_expression
           ;

comp_operator : '<' | '>' | EQUAL | ">=" | "<=" | "!="
              | "is" ("not")? | ("not")? "in"
              ;

comparison : (left_comparison|a_expr) comp_operator a_expr %expand { $$ = make_binop($*, COMPARE); }
           | a_expr
           ;

left_comparison : (left_comparison|a_expr) comp_operator a_expr %expand { $$ = make_binop($*, LEFT_COMPARE); }
                ;

a_expr : m_expr
       | a_expr ('-'|'+') m_expr %expand { $$ = make_binop($*, BINOP); }
       ;

m_expr : u_expr
       | m_expr ('*'|"//"|"/"|'%') u_expr %expand { $$ = make_binop($*, BINOP); }
       ;

u_expr : power
       | ('-'|'+') u_expr %expand { $$ = make_unop($*); }
       ;

power : primary ("**" u_expr)? { if ( ! $u_expr.missing() ) { $$ = make_binop( $*, BINOP); } }
      ;

keyword_item : identifier ASGN! expression
             ;

keyword_arguments : keyword_item (','! keyword_item)*
                  ;

positional_arguments : expression (','! expression)*
                     ;

argument_list : positional_arguments (','! keyword_arguments)?
              | keyword_arguments
              ;

call : primary '('! (argument_list (','!)?)? ')'! { $$ = $^(CALL, $primary, $^(EXPR_LIST, $argument_list)); }
     ;

upper_bound : expression
            ;

lower_bound : expression
            ;

simple_slicing : primary '['! (lower_bound) ':'! (upper_bound) ']'! { $$ = $^(SLICE, $*); }
               | primary '['! ':'! (upper_bound) ']'! { $$ = $^(SLICE, $primary, $^(EMPTY), $upper_bound); }
               | primary '['! (lower_bound) ':'! ']'! { $$ = $^(SLICE, $primary, $lower_bound, $^(EMPTY)); }
               | primary '['! ':'! ']'!               { $$ = $^(SLICE, $primary,  $^(EMPTY), $^(EMPTY)); }
               ;

slicing : simple_slicing
        ;

subscription : primary '['! expression_list ']'! { $$ = $^(SUBSCRIPT, $*); }
             ;

attributeref : primary '.'! identifier { $$ = $^(ATTREF, $*); }
             ;

primary : atom | attributeref | subscription
        | slicing | call
        ;

key_datum : expression ':'! expression { $$ = $^(PAIR, $*); }
          ;

key_datum_list : key_datum (','! key_datum)* (','!)?
               ;

dict_display : '{'! (key_datum_list)? '}'! { $$ = $^(DICT_DISP); }
             | '{'! (key_datum_list) '}'! { $$ = $^(DICT_DISP, $key_datum_list); }
             ;

list_display : '['! expression (','! expression)* (','!)? ']'! { $$ = $^(LIST_DISP, $*); }
             | '[' ']' { $$ = $^(LIST_DISP); }
             ;

parenth_form : '('! expression_list ')'!
             | '('! ')'! { AST_Ptr tok = $^(TUPLE); tok->set_loc(yysource_location()); $$ = tok; }
             ;

/** should this be here? there's one defined above. */
stringliteral : STRING | RAWSTRING
              ;

literal : stringliteral | integer
        ;

enclosure : parenth_form | list_display
          | dict_display
          ;

atom : identifier | literal | enclosure
     ;

integer : INT_LITERAL
        ;

typed_id : ID TYPE_OP! type { $$ = $^(TYPED_ID, $*); }
         | id_type_op type { $$ = $^(TYPED_ID, $*); }
         ;

type : type_id
     | type_var
     | '('! type_list0 ')'! "->"! type { $$ = $^(FUNCTION_TYPE, $type, $type_list0); }
     ;

type_var : TYPE_VAR
         ;

type_id : identifier { $$ = $^(TYPE, $identifier, $^(TYPE_LIST)); }
        | identifier "of"! '['! type_list0 ']'! { $$ = $^(TYPE, $*); }
        | identifier "of"! type { $$ = $^(TYPE, $identifier, $^(TYPE_LIST, $type)); }
        ;

type_list0 : type (','! type)* { $$ = $^(TYPE_LIST, $*); }
           | /* empty */ { $$ = $^(TYPE_LIST); }
           ;

type0 : type
      | /* empty */ { $$ = $^(EMPTY); }
      ;

identifier : ID
           | illegal_keyword
           ;

id_type_op : ID_TYPE_OP ;

keyword : "and"     | "not"      | "while"
        | "elif"    | "or"
        | "else"    | "if"      | "pass"
        | "break"   | "print"
        | "class"   | "in"
        | "continue"| "is"      | "return"
        | "def"     | "for"
        ;

illegal_keyword : ( "as"     | "assert" | "del"     | "except"
                  | "exec"   | "from"   | "finally" | "future"
                  | "global" | "import" | "lambda"
                  | "raise"  | "try" | "with" | "yield"
                  ) { error(yysource_location(), "invalid keyword"); };

/* Shoulda been built-in */
_DIGIT : ('0' .. '9')
       ;

_LOWER : ('a' .. 'z')
       ;

_UPPER : ('A' .. 'Z')
       ;

_LETTER : (_LOWER | _UPPER)
        ;

_NEWLINE : "\r"? "\n" ;
NEWLINE : "\r"? "\n" ;

/* Identifiers */
ID : (_LETTER | '_') (_LETTER | _DIGIT | '_')*
   ;

TYPE_VAR : '$' (_LETTER | '_') (_LETTER | _DIGIT | '_')*
         ;

/* Operators */
ASGN : '='
      ;

EQUAL : "=="
      ;

TYPE_OP : "::"
        ;

ID_TYPE_OP : (_LETTER | '_') (_LETTER | _DIGIT | '_')* "::"
           ;

/* Integers */
_OCTDIGIT : ('0' .. '7')
          ;
_OCTINTEGER : '0' _OCTDIGIT+
            ;

_HEXDIGIT : _DIGIT | ('a' .. 'f') | ('A' .. 'F')
          ;
_HEXINTEGER : '0' ('x' | 'X') _HEXDIGIT+
            ;

_NONZERODIGIT : ('1' .. '9')
              ;

_DECIMALINTEGER : _NONZERODIGIT _DIGIT* | '0'
                ;

INT_LITERAL : _DECIMALINTEGER | _OCTINTEGER | _HEXINTEGER
            ;

/* Strings whoop whoop */
_STRINGCHARS : _ANY - ('\\'|'\''|'"'|'\n'|'\r')
             ;
_SHORTSTRINGCHARS : _STRINGCHARS | '\\'
                  ;
_LONGSTRINGCHARS : _STRINGCHARS  | _NEWLINE
                ;

_RAWESCAPESEQ : '\\' _ANY
              ;
_ESCAPESEQ : _RAWESCAPESEQ | '\\'  _OCTDIGIT _OCTDIGIT? _OCTDIGIT?
           ;

_STRING_NOT_DOUBLEQ : _STRINGCHARS | '\''
                    ;
_STRING_NOT_SINGLEQ : _STRINGCHARS | '"'
                    ;

_SHORTSTRING : '\'' ( _STRING_NOT_SINGLEQ | _ESCAPESEQ )* '\''
             | '"' ( _STRING_NOT_DOUBLEQ | _ESCAPESEQ )* '"'
             ;
_RAWSHORTSTRING : '\'' ( _STRING_NOT_SINGLEQ | _RAWESCAPESEQ )* '\''
                | '"' ( _STRING_NOT_DOUBLEQ | _RAWESCAPESEQ )* '"'
                ;
_LONGSTRING_SINGLE : '"'  | _LONGSTRINGCHARS | _LONGSTRINGCHARS '\'' | _LONGSTRINGCHARS "''" | _LONGSTRINGCHARS "\\'''"
                   ;
_LONGSTRING_DOUBLE : '\'' | _LONGSTRINGCHARS | _LONGSTRINGCHARS '"' | _LONGSTRINGCHARS "\"\"" | _LONGSTRINGCHARS "\\\"\"\""
                   ;

_LONGSTRING : "\"\"\"" ( _LONGSTRING_DOUBLE | _ESCAPESEQ )* "\"\"\""
            | "'''" ( _LONGSTRING_SINGLE | _ESCAPESEQ )* "'''"
            ;
_RAWLONGSTRING : "\"\"\"" ( _LONGSTRING_DOUBLE | _RAWESCAPESEQ )* "\"\"\""
            | "'''" ( _LONGSTRING_SINGLE | _RAWESCAPESEQ )* "'''"
            ;

STRING : _SHORTSTRING  { $$ = AST::make_token(STRING, $TEXT_SIZE - 2, $TEXT + 1); }
       | _LONGSTRING { $$ = AST::make_token(STRING, $TEXT_SIZE - 6, $TEXT + 3); }
       ;
RAWSTRING : ('r'|'R') _RAWSHORTSTRING {  $$ = AST::make_token(RAWSTRING, $TEXT_SIZE - 3, $TEXT + 2); }
          |  ('r'|'R') _RAWLONGSTRING {  $$ = AST::make_token(RAWSTRING, $TEXT_SIZE - 7, $TEXT + 4); }
          ;

/* Handle bad strings */
* : ( ('r'|'R')? ( '\'' ( _STRING_NOT_SINGLEQ | _ESCAPESEQ )*
  | '"' ( _STRING_NOT_DOUBLEQ | _ESCAPESEQ )* )) { error(yysource_location(), "unterminated short string"); }
  ;

* : ( ('r'|'R')? ( ("\"\"\"" ( _LONGSTRING_DOUBLE | _ESCAPESEQ )* )
  | ("'''" ( _LONGSTRING_SINGLE | _ESCAPESEQ )* ) )) { error(yysource_location(), "unterminated long string"); }
  ;

/* Comments and blank lines */
_SAMELINE : _ANY - ('\n');
* : _BOL (' ' | '\t' | '\r')* '#'_SAMELINE* _NEWLINE %prefer { YYIGNORE; }
  | (' ' | '\t' | '\r')* '#' _SAMELINE* _EOL { YYIGNORE; }
  ;

* : _BOL  (' ' | '\t' | '\r' )* _NEWLINE %prefer { YYIGNORE; }
  ;

/* Handle indentation at the beginning of a line. */
* : _BOL (' ' | '\t')* %prefer { processIndent($TEXT); }
  ;

/* line continuation */
* : '\\' (' ' | '\t' )* _NEWLINE (' ' | '\t' )*   %prefer { YYIGNORE; }
//  | '('|','  (' ' | '\t' )* _NEWLINE (' ' | '\t' )*  { YYIGNORE; }
  ;


/* Normally, throw away whitespace other than newline. */
* : (' ' | '\t' | '\r')+
  ;

%%

bool debugParser = false;

static AST_Ptr
make_unop (const List_Ptr& operands)
{
    return YYMAKE_TREE (UNOP, make_id (operands->at (0)), operands->at (1));
}

static AST_Ptr
make_binop (const List_Ptr& operands, const int token)
{
    return YYMAKE_TREE (token, operands->at (0), make_id (operands->at (1)),
                        operands->at (2));
}

static AST_Ptr
make_id (AST_Ptr& token)
{
    AST_Ptr result = AST::make_token (ID, token->text_size (),
                                      token->as_chars (), false);
    result->set_loc (token->loc ());
    return result;
}

int
AST::lineNumber ()
{
    return yylocation_line (loc ());
}

void
parse (FILE* f, const string& name)
{
    if (debugParser)
        yydebug = 1;
    yypush_lexer (f, name);
    theTree = NULL;
    yyparse ();
    if (theTree != NULL) {
        theTree->print (cout, 0);
    }
}

int
indentLength (const char* text)
{
    int size = strlen(text);
    int blnks = 0;
    for(int i = 0; i < size; i++) {
        switch (text[i] ) {
        default: break;
        case ' ': blnks += 1; break;
        case '\t': blnks += 8 - (blnks % 8); break;
        }
    }
    return blnks;
}

void processIndent( const char* text)
{
  int length = indentLength(text);
  if ( indents.empty() ) {
    indents.push(0);
  }
  if ( length > indents.top()  ) {
    indents.push(length);
    yyqueue_token( INDENT, 0 );
  } else if ( length < indents.top() ) {
    while ( !indents.empty() ) {
      indents.pop();
      if ( length < indents.top() ) {
        yyqueue_token( DEDENT, 0 );
        continue;
      }
      if ( length != indents.top()){
        error(yysource_location(), "inconsistent indentation");
      }
      if ( length == indents.top() ) {
        yyqueue_token( DEDENT, 0 );
        break;
      }
    }
  }
}

void validTargetList(const AST_Ptr& token)
{
  string type = getTokenType(token);
  bool valid = true;
  if (type == "expr_list")
    for_each_child (c, token) {
      type = getTokenType(c);
      if (type != "id" && type != "attributeref" && type != "subscription" && type != "slicing" && type != "typed_id") valid = false;
    } end_for;
  else if (type != "id" && type != "attributeref" && type != "subscription" && type != "slicing" && type != "typed_id") valid = false;

  if (!valid) error(yysource_location(), "assignment @expr_list not equivalent to @target_list");
}

string getTokenType(const AST_Ptr& token)
{
  std::stringstream buffer;
  token->print(buffer, 0);
  string print = buffer.str();
  size_t pLoc = print.find("(");
  size_t spLoc = print.find(" ");

  if (pLoc != string::npos)
    if (spLoc != string::npos)
      return print.substr(pLoc + 1, spLoc - (pLoc + 1));

  return "";
}

