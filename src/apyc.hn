/* -*- mode: fundamental; c-file-style: "stroustrup"; indent-tabs-mode: nil -*- */

/* apyc: Bison Parser */

/* Authors: */

%define semantic_tree_type "AST"

%{
  #include <string>
  #include <stack>
  #include "apyc.h"
  #include "ast.h"
  #include <stack>

  using namespace std;

  static AST_Ptr theTree;

  /* Utilities */
  /** Return a new unop node corresponding to OPERANDS, which is the list of
   *  right-hand-side semantic values of a unop production (consisting of a
   *  token for the operator, followed by the AST for the operand). */
  static AST_Ptr make_unop (const List_Ptr& operands);

  /** Return a new binop node corresponding to OPERANDS, which is the list of
   *  right-hand-side semantic values of a binop production (consisting of an
   *  AST for the first operand, a token for the operator, and an AST for the
   *  second operand). */
  static AST_Ptr make_binop (const List_Ptr& operands);

  /** Return a new ID node, where the text of the identifier is given by
   *  TOKEN. */
  static AST_Ptr make_id (AST_Ptr& token);

  static stack<int> indents;

%}

%debug
%define error_function error

/* A token declaration such as
 *   %token INDENT
 * declares a new integer constant INDENT, which serves as a syntactic category
 * (suitable for output by the lexer) identifying a kind of token, which we
 * also often refer to as INDENT. A declaration such as
 *   %token IF "if"
 * defines a constant IF and makes it the syntactic category for the token
 * "if".  The built-in function yyexternal_token_name(...) maps between
 * syntactic categories (like IF) and the token strings defined in these
 * %token declarations (like "if").
 *
 * The Horn system uses tokens as leaf nodes and as AST node operators.  A
 * rule such as
 *     if_stmt: "if"^ expression ":"! ...
 * with no action, by default creates an AST node whose operator is an "if"
 * token (with syntactic category IF, given the %token declaration above).
 * When the node type does not correspond to a token that appears in the
 * program, we define a dummy token type that serves only as an AST
 * node type.  For example, we can define
 *     %token DICT_DISPLAY ...
 * and then use
 *     dict_display: "{"! key_datum_list? "}"!
 *              { $$ = $^(DICT_DISPLAY, $*); }
 * in the grammar (using DICT_DISPLAY only in actions, not as a grammar
 * symbol).
 *
 * In this skeleton, we've used a simple kludge to extract the printed forms
 * of AST operators from the operators themselves.  When a token such as IF
 * is the operator, yyexternal_token_name returns the operator name directly.
 * When there is no such correspondence, as with DICT_DISPLAY, we'll define
 *     %token DICT_DISPLAY "@dict_display"
 * Since "@dict_display" is not a valid token (it would be an error for this
 * to appear in any Python program) and does not appear in the grammar, this
 * declaration has no effect on the language recognized.  However, it
 * still provides an easy way to find the external name of an operator (just
 * strip off the leading "@").  (We can't just use "dict_display", since that
 * would tell Horn to define 'dict_display' as a token, whereas it would be a
 * simple identifier if it actually appeared in a Python program.  This is
 * where the kludginess comes in.) The AST_Tree::external_name method does
 * this conversion, converting tokens that are supposed to represent
 * node operators to printable strings.
 */

%token PRINTLN "@println"
%token EMPTY
%token EXPR_LIST "@expr_list"
%token MODULE "@module"
%token BINOP "@binop"
%token UNOP "@unop"
%token INDENT
%token DEDENT
/* FIXME: MORE... */

%%

program : stamt_list* { theTree = $^(MODULE, $*); $$ = NULL; }
        ;
        
input_input : expression_list '\n'!;

eval_input : expression_list ('\n')*!;

interactive_input : (stmt_list)? '\n'!
                  | compound_stmt '\n'!
                  ;

file_input : ('\n'! | statement)* ;

classname : identifier ;

inheritance : "("! (expression_list)? ")"! ;

classdef : "class" classname (inheritance)? ":"!
            suite
            ;
            
funcname : identifier ;

parameter : identifier;

defparameter : parameter ("="! expression)? ;

parameter_list : (defparameter ","!)*
                (defparameter (","!)?)
                ;

funcdef : "def"! funcname "("! (parameter_list)? ")"! ":"! suite ;

for_stmt : "for"! target_list "in"! expression_list
            ":"! suite ("else"! ":"! suite)? ;
            
while_stmt : "while"! expression ":"! suite ("else"! ":"! suite)? ;

if_stmt : "if"! expression ":"! suite
            ( "elif"! expression ":"! suite)*
            ("else"! ":" suite)?
            ;
            
stmt_list : simple_stmt (";"! simple_stmt)* (";"!)? ;

statement : stmt_list '\n'!| compound_stmt ;

suite : stmt_list '\n'!
        | '\n'! INDENT! statement+ DEDENT!
        ;
        
compound_stmt : if_stmt
              | while_stmt
              | for_stmt
              | funcdef
              | classdef
              ;
              
name : identifier ;

relative_module : ("."!)* module | ("."!)+ ;

module : (identifier "."!)* identifier ;

continue_stmt : "continue" ;

break_stmt : "break" ;

return_stmt : "return"! (expression_list)? ;

print_stmt : "print"! (expression (","! expression)* (","!)?)? ;

pass_stmt : "pass" ;

target : identifier
       | attributeref
       | subscription
       | slicing
       ;
       
target_list : ("("!)? target (","! target)* (","!)? (")"!)? 
            | ("["!)? target (","! target)* (","!)? ("]"!)?

stamt_list : (INDENT!|DEDENT!)? print_stamt '\n'!;

print_stamt : "print" expression_list { $$ = $^(PRINTLN, $expression_list); }
           ;

/* Grammar */
identifier : ID
           ;

string_literal : STRING
               | RAWSTRING
               ;
               
int_literal : INT_LITERAL ;

int_literal : INT_LITERAL
            ;

expression_list : expression (","! expression)* { $$ = $^(EXPR_LIST, $*); }
                | /*empty*/ { $$ = $^(EXPR_LIST); }
                ;

expression : identifier
           | string_literal
           | int_literal
           ;

/* DISABLED: WIP
 *
 * keyword : "and"     | "del"     | "from"    | "not"     | "while"
 *         | "as"      | "elif"    | "global"  | "or"      | "with"
 *         | "assert"  | "else"    | "if"      | "pass"    | "yield"
 *         | "break"   | "except"  | "import"  | "print"
 *         | "class"   | "exec"    | "in"      | "raise"
 *         | "continue"| "finally" | "is"      | "return"
 *         | "def"     | "for"     | "lambda"  | "try"
 *         ;
 *
 * letter : lowercase | uppercase
 *        ;
 *
 * lowercase : _LOWER
 *           ;
 *
 * uppercase : _UPPER
 *           ;
 *
 * digit : _DIGIT
 *       ;
 *
 * integer : INT_LITERAL
 *         ;
 *
 * atom : identifier | literal | enclosure
 *      ;
 *
 * enclosure : parenth_form | list_display
             | dict_display | string_conversion
 *           ;
 *
 * literal : stringliteral | integer
 *         ;
 *
 * stringliteral : _STRING
 *
 * parenth_form : '(' (expression_list)? ')'
 *              ;
 *
 * list_display : '[' (expression_list | list_comprehension)? ']'
 *              ;
 *
 * list_comprehension : expression list_for
 *                    ;
 *
 * list_for : "for" target_list "in" old_expression_list (list_iter)?
 *          ;
 *
 * old_expression_list : old_expression ((',' old_expression)+ (',')?)?
 *
 * list_iter : list_for | list_if
 *           ;
 *
 * list_if : "if" old_expression (list_iter)?
 *         ;
 *
 * dict_display : '{' (key_datum_list)? '}'
 *              ?
 *
 * key_datum_list : key_datum (',' key_datum)* (',')?
 *                ?
 *
 * key_datum : expression ':' expression
 *           ;
 *
 * string_conversion : '`' expression_list '`'
 *                   ;
 *
 * primary : atom | attrbuteref | subscription
 *         | slicing | call
 *         ;
 *
 * attributeref : primary '.' identifier
 *              ;
 *
 * subscription : primary '[' expression_list ']'
 *              ;
 *
 * slicing : simple_slicing
 *         ;
 *
 * simple_slicing : primary '[' short_slice ']'
 *                ;
 *
 * slice_list : slice_item (',' slice_item)* (',')?
 *            ;
 *
 * proper_slice : short_slice
 *              ;
 *
 * short_slice : (lower_bounce)? ':' (upper_bound)?
 *             ;
 *
 * ellipsis : "..."
 *          ;
 *
 * call : primary '(' argument_list (',')? ')'
 *      ;
 *
 * argument_list : positional_arguments (',' keyword_arguments)?
 *               | keyword_arguments
 *               ;
 *
 * positional_arguments : expression (',' expression)*
 *                      ;
 *
 * keyword_arguments : keyword_item (',' keyword_item)*
 *                   ;
 *
 * keyword_item : identifier '=' expression
 *              ;
 *
 * power : primary ("**" u_expr)?
 *       ?
 *
 * u_expr : power | '-' u_expr | '+' u_expr
 *        ;
 *
 * m_expr : u_expr | m_expr '*' u_expr
 *        | m_expr "//" u_expr | m_expr "/" u_expr
 *        | m_expr '%' u_expr
 *        ;
 *
 * a_expr : m_expr | a_expr '+' m_expr
 *        | a_expr '-' m_expr
 *        ;
 *
 * and_expr : a_expr | and_expr '&' a_expr
 *          ;
 *
 * comparison : and_expr (comp_operator and_expr)*
 *            ;
 *
 * comp_operator : _COMPARISON_OPERATORS
 *               ;
 *
 * expression : conditional_expression
 *            ;
 *
 * old_expression : or_test
 *                ;
 *
 * conditional_expression : or_test ("if" or_test "else" expression)?
 *                        ;
 *
 * or_test : and_test | or_test "or" and_test
 *         ;
 *
 * and_test : not_test | and_test "and" not_test
 *          ;
 *
 * not_test : comparison | "not" not_test
 *          ;
 *
 * expression_list : expression (',' expression)* (',')?
 *                 ;
 *
 * simple_stmt : expression_stmt
 *             | assignment_stmt
 *             | print_stmt
 *             | return_stmt
 *             | break_stmt
 *             | continue_stmt
 *             ;
 *
 * expression_stmt : expression_list
 *                 ;
 *
 * assignment_stmt : (target_list '=')+ expression_list
 *                 ;
 *
 */

/* Shoulda been built-in */
_COMPARISON_OPERATORS : '<' | '>' | "==" | ">=" | "<=" | "!="
                      | "is" ("not")? | ("not")? "in"
                      ;
_DIGIT : ('0' .. '9')
       ;
_LOWER : ('a' .. 'z')
       ;
_UPPER : ('A' .. 'Z')
       ;
_LETTER : (_LOWER | _UPPER)
        ;

/* Identifiers */
ID : (_LETTER | '_') (_LETTER | _DIGIT | '_')* { $$ = AST::make_token(ID, $TEXT_SIZE, $TEXT); }
   ;

/* Integers */
_OCTDIGIT : ('0' .. '7')
          ;
_OCTINTEGER : '0' _OCTDIGIT+
            ;

_HEXDIGIT : _DIGIT | ('a' .. 'f') | ('A' .. 'F')
          ;
_HEXINTEGER : '0' ('x' | 'X') _HEXDIGIT+
            ;

_NONZERODIGIT : ('1' .. '9')
              ;

_DECIMALINTEGER : _NONZERODIGIT _DIGIT* | '0'
                ;

INT_LITERAL : _DECIMALINTEGER | _OCTINTEGER | _HEXINTEGER
            ;

/* Strings whoop whoop */
_STRINGCHARS : _ANY - ('\\'|'\''|'"'|'\n')
             ;
_SHORTSTRINGCHARS : _STRINGCHARS | '\\'
                  ;
_LONGSTRINGCHARS : _STRINGCHARS  | '\n'
                ;

_RAWESCAPESEQ : '\\' _ANY
              ;
_ESCAPESEQ : _RAWESCAPESEQ | '\\'  _OCTDIGIT _OCTDIGIT? _OCTDIGIT?
           ;

_STRING_NOT_DOUBLEQ : _STRINGCHARS | '\''
                    ;
_STRING_NOT_SINGLEQ : _STRINGCHARS | '"'
                    ;

_SHORTSTRING : '\'' ( _STRING_NOT_SINGLEQ | _ESCAPESEQ )* '\''
             | '"' ( _STRING_NOT_DOUBLEQ | _ESCAPESEQ )* '"'
             ;
_RAWSHORTSTRING : '\'' ( _STRING_NOT_SINGLEQ | _RAWESCAPESEQ )* '\''
                | '"' ( _STRING_NOT_DOUBLEQ | _RAWESCAPESEQ )* '"'
                ;
_LONGSTRING_SINGLE : '"'  | _LONGSTRINGCHARS | _LONGSTRINGCHARS '\'' | _LONGSTRINGCHARS "''" | _LONGSTRINGCHARS "\\'''"
                   ;
_LONGSTRING_DOUBLE : '\'' | _LONGSTRINGCHARS | _LONGSTRINGCHARS '"' | _LONGSTRINGCHARS "\"\"" | _LONGSTRINGCHARS "\\\"\"\""
                   ;

_LONGSTRING : "\"\"\"" ( _LONGSTRING_DOUBLE | _ESCAPESEQ )* "\"\"\""
            | "'''" ( _LONGSTRING_SINGLE | _ESCAPESEQ )* "'''"
            ;
_RAWLONGSTRING : "\"\"\"" ( _LONGSTRING_DOUBLE | _RAWESCAPESEQ )* "\"\"\""
            | "'''" ( _LONGSTRING_SINGLE | _RAWESCAPESEQ )* "'''"
            ;

STRING : _SHORTSTRING  { $$ = AST::make_token(STRING, $TEXT_SIZE - 2, $TEXT + 1); }
       | _LONGSTRING { $$ = AST::make_token(STRING, $TEXT_SIZE - 6, $TEXT + 3); }
       ;
RAWSTRING : ('r'|'R') _RAWSHORTSTRING {  $$ = AST::make_token(RAWSTRING, $TEXT_SIZE - 3, $TEXT + 2); }
          |  ('r'|'R') _RAWLONGSTRING {  $$ = AST::make_token(RAWSTRING, $TEXT_SIZE - 7, $TEXT + 4); }
          ;

/* Handle bad strings */
* : ( ('r'|'R')? ( '\'' ( _STRING_NOT_SINGLEQ | _ESCAPESEQ )*
  | '"' ( _STRING_NOT_DOUBLEQ | _ESCAPESEQ )* )) { error(yysource_location(), "unterminated short string"); }
  ;

* : ( ('r'|'R')? ( ("\"\"\"" ( _LONGSTRING_DOUBLE | _ESCAPESEQ )* )
  | ("'''" ( _LONGSTRING_SINGLE | _ESCAPESEQ )* ) )) { error(yysource_location(), "unterminated long string"); }
  ;

/* Handle indentation at the beginning of a line. */
* : _BOL (' ' | '\t')* %prefer { YYSET_TOKEN(processIndent($TEXT)); }
  ;

/* Normally, throw away whitespace other than newline. */
* : (' ' | '\t' | '\r')+
  ;

%%

bool debugParser = true;

static AST_Ptr
make_unop (const List_Ptr& operands)
{
    return YYMAKE_TREE (UNOP, make_id (operands->at (0)), operands->at (1));
}

static AST_Ptr
make_binop (const List_Ptr& operands)
{
    return YYMAKE_TREE (BINOP, operands->at (0), make_id (operands->at (1)),
                        operands->at (2));
}

static AST_Ptr
make_id (AST_Ptr& token)
{
    AST_Ptr result = AST::make_token (ID, token->text_size (),
                                      token->as_chars (), false);
    result->set_loc (token->loc ());
    return result;
}

int
AST::lineNumber ()
{
    return yylocation_line (loc ());
}

void
parse (FILE* f, const string& name)
{
    if (debugParser)
        yydebug = 1;
    yypush_lexer (f, name);
    theTree = NULL;
    yyparse ();
    if (theTree != NULL) {
        theTree->print (cout, 0);
    }
}

int
indentLength (const char* text)
{
    int size = strlen(text);
    int blnks = 0;
    for(int i = 0; i < size; i++) {
        switch (text[i] ) {
        default: break;
        case ' ': blnks += 1; break;
        case '\t': blnks += 8 - (blnks % 8); break;
        }
    }
    return blnks;
}

int processIndent( const char* text )
{
  int length = indentLength(text);
  if ( indents.empty() ) {
    indents.push(0);
  }
  if ( length > indents.top()  ) {
    indents.push(length);
    return INDENT;
  } else if ( length < indents.top() ) {
    while ( !indents.empty() ) {
      indents.pop();
      if ( length > indents.top() ) {
        continue;
      }
      if ( length != indents.top() ){
        error(yysource_location(), "inconsistent indentation");
      }
      return DEDENT;
    }
  }

  return -1;
}
